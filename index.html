<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>insurance ai</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.19.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    :root{--bg:#0b1220;--panel:#0f1830;--text:#e9eeff;--line:#24355a;--accent:#7aa2ff;--muted:#9fb1ff}
    *{box-sizing:border-box;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    body{margin:0;background:radial-gradient(1000px 500px at 50% -10%,#16214a 0%,#0b1220 60%,#0b1220 100%);color:var(--text);min-height:100dvh;display:grid;place-items:center}
    .wrap{width:100%;max-width:820px;display:grid;gap:18px;justify-items:center;padding:22px}
    .topbar{width:100%;display:flex;justify-content:space-between;align-items:center}
    .title{font-size:24px;font-weight:900;letter-spacing:.3px}
    .link{font-size:12px;color:#bcd0ff;text-decoration:none;border:1px solid #30456f;padding:6px 10px;border-radius:10px}
    .panel{width:100%;background:linear-gradient(180deg,#0f1830,#0b142b);border:1px solid var(--line);border-radius:18px;padding:20px;display:grid;gap:16px;justify-items:center;box-shadow:0 20px 45px rgba(0,0,0,.35)}
    .stack{display:grid;gap:10px;width:100%;max-width:560px}
    .seg{display:inline-grid;grid-auto-flow:column;gap:6px;background:#0c1633;border:1px solid #30456f;border-radius:12px;padding:6px}
    .seg button{background:transparent;border:none;color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer}
    .seg button.active{background:var(--accent);color:#0b1220;font-weight:800}
    .btn{background:var(--accent);border:none;padding:12px 16px;border-radius:12px;color:#0b1220;font-weight:800;cursor:pointer;display:inline-block;text-align:center}
    .btn.secondary{background:#12224f;color:var(--text);border:1px solid #30456f}
    .btn.ghost{background:transparent;color:var(--text);border:1px dashed #30456f}
    .label{font-size:12px;color:var(--muted);margin-top:-6px;margin-bottom:4px}
    .drop{width:100%;border:2px dashed #36508a;border-radius:14px;padding:18px;display:grid;place-items:center;background:#0b1430;cursor:pointer}
    .drop.dragover{background:#0d1840}
    input[type=file]{display:none}
    .gridBtns{display:grid;gap:10px;width:100%;grid-template-columns:1fr 1fr}
    .gridBtns>button{width:100%}
    .wideBtns{display:grid;gap:10px;width:100%;grid-template-columns:1fr}
    .value{font-size:34px;font-weight:900;letter-spacing:.5px}
    .status{font-size:12px;color:var(--muted)}
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;align-items:center;justify-content:center}
    .sheet{width:92%;max-width:640px;background:#0f1830;border:1px solid #2a3f6c;border-radius:14px;padding:16px;display:grid;gap:10px}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .sheet label{font-size:12px;color:var(--muted)}
    .sheet input,.sheet select{width:100%;padding:10px;border-radius:10px;border:1px solid #30456f;background:#0b1430;color:var(--text)}
    .sheet .actions{display:flex;gap:10px;justify-content:flex-end;margin-top:6px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">insurance ai</div>
      <a id="siteLink" class="link" href="#" target="_blank" rel="noopener">Open website</a>
    </div>

    <div class="panel">
      <div class="stack" style="justify-items:center">
        <div class="seg">
          <button id="modeTab" type="button" class="active">Tabular (MLP)</button>
          <button id="modeSeq" type="button">Sequence (RNN)</button>
        </div>
      </div>

      <div class="stack">
        <div class="label">train.csv — required</div>
        <div id="dropTrain" class="drop">
          <button id="pickTrain" type="button" class="btn">Upload train.csv</button>
          <input id="trainInput" type="file" accept=".csv,text/csv" />
        </div>
        <div class="label">test.csv — optional</div>
        <div id="dropTest" class="drop">
          <button id="pickTest" type="button" class="btn secondary">Upload test.csv</button>
          <input id="testInput" type="file" accept=".csv,text/csv" />
        </div>
      </div>

      <div class="stack">
        <div class="wideBtns">
          <button id="trainBtn" type="button" class="btn" disabled>Train model</button>
        </div>
        <div class="gridBtns">
          <button id="predictBtn" type="button" class="btn secondary" disabled>Predict on test.csv</button>
          <button id="downloadBtn" type="button" class="btn ghost" disabled>Download predictions.csv</button>
        </div>
        <div class="wideBtns">
          <button id="manualBtn" type="button" class="btn secondary" disabled>Manual calculator</button>
          <button id="resetBtn" type="button" class="btn ghost">Reset</button>
        </div>
      </div>

      <div id="value" class="value">—</div>
      <div id="status" class="status"></div>
    </div>
  </div>

  <!-- Modal for manual calculator (MLP mode) -->
  <div id="modal" class="modal">
    <div class="sheet">
      <div style="font-weight:700">Calculator</div>
      <div id="formBox" class="row"></div>
      <div id="calcOut" class="value" style="font-size:22px">—</div>
      <div class="actions">
        <button id="calcBtn" type="button" class="btn">Calculate</button>
        <button id="closeBtn" type="button" class="btn secondary">Close</button>
      </div>
    </div>
  </div>

<script>
// ===== Site link handling =====
(function(){
  const params=new URLSearchParams(location.search);
  const site=params.get('site');
  const a=document.getElementById('siteLink');
  a.href=site||location.href; a.textContent='Open website';
})();

// ===== State =====
let MODE='tab'; // 'tab' for MLP; 'seq' for RNN
let trainRows=[], testRows=[]; let columns=[], target='charges';
let catCols=[], numCols=[], enc={}; let model=null; let preds=null;
let seqInfo={idCol:null, timeCol:null, featCols:[], T:12, featDim:0};

const $=id=>document.getElementById(id);
function setStatus(t){ $("status").textContent = t||''; }
function setValue(v){ $("value").textContent = v; }

// ===== Mode toggle =====
$("modeTab").onclick=()=>{ MODE='tab'; $("modeTab").classList.add('active'); $("modeSeq").classList.remove('active'); $("manualBtn").disabled = !columns.length; setStatus('Tabular mode'); };
$("modeSeq").onclick=()=>{ MODE='seq'; $("modeSeq").classList.add('active'); $("modeTab").classList.remove('active'); $("manualBtn").disabled = true; setStatus('Sequence mode'); };

// ===== Upload helpers (train & test) =====
function wireDrop(zone, input, onFiles){
  ['dragenter','dragover'].forEach(evt=> zone.addEventListener(evt, e=>{e.preventDefault();zone.classList.add('dragover');}));
  ;['dragleave','drop'].forEach(evt=> zone.addEventListener(evt, e=>{e.preventDefault();zone.classList.remove('dragover');}));
  zone.addEventListener('drop', e=> onFiles([...e.dataTransfer.files]));
  // Full-zone click opens input
  zone.addEventListener('click', ()=> input.click());
  input.addEventListener('change', e=> onFiles([...e.target.files]));
}

wireDrop($("dropTrain"), $("trainInput"), files=>{ const f=files[0]; if(!f) return; parseCSV(f,true); });
wireDrop($("dropTest"), $("testInput"), files=>{ const f=files[0]; if(!f) return; parseCSV(f,false); });
$("pickTrain").onclick=()=> $("trainInput").click();
$("pickTest").onclick =()=> $("testInput").click();

function parseCSV(file, isTrain){
  Papa.parse(file,{header:true,dynamicTyping:true,skipEmptyLines:true,complete:(res)=>{
    if(isTrain){ trainRows=res.data; columns=res.meta.fields||Object.keys(trainRows[0]||{}); setStatus(`train: ${trainRows.length}`); $("trainBtn").disabled=false; if(MODE==='tab'){ guessSchema(); buildForm(); $("manualBtn").disabled=false; } else { detectSeqSchema(); } }
    else { testRows=res.data; setStatus(`${$("status").textContent} | test: ${testRows.length}`); $("predictBtn").disabled = !(model && testRows.length); }
  }});
}

// ===== TABULAR (MLP) =====
function guessSchema(){
  const cols = (columns||[]).filter(c=>c!==target);
  catCols=[]; numCols=[];
  for(const c of cols){
    const vals=trainRows.map(r=>r[c]).filter(v=>v!==null&&v!==undefined);
    const numRatio = vals.filter(v=> typeof v==='number' && !Number.isNaN(v)).length/Math.max(vals.length,1);
    if(numRatio>0.85 && new Set(vals).size>15) numCols.push(c); else catCols.push(c);
  }
}

function fitEnc(){
  enc={};
  for(const c of numCols){
    const xs=trainRows.map(r=>Number(r[c])).filter(v=>!Number.isNaN(v));
    const mean=xs.reduce((a,b)=>a+b,0)/Math.max(xs.length,1);
    const std=Math.sqrt(xs.reduce((a,b)=>a+(b-mean)*(b-mean),0)/Math.max(xs.length,1))||1;
    const med=xs.slice().sort((a,b)=>a-b)[Math.floor(xs.length/2)]||0;
    enc[c]={type:'num',mean,std,med};
  }
  for(const c of catCols){
    const uniq=[...new Set(trainRows.map(r=> (r[c]===undefined||r[c]===null||r[c]==='')?'∅':String(r[c])) )];
    enc[c]={type:'cat',map:Object.fromEntries(uniq.map((k,i)=>[k,i])),size:uniq.length};
  }
}

function rowToX_tab(r){
  const out=[];
  for(const c of numCols){ const e=enc[c]; const v=Number(r[c]); const x=Number.isNaN(v)?e.med:v; out.push((x-e.mean)/e.std); }
  for(const c of catCols){ const e=enc[c]; const arr=new Array(e.size).fill(0); const k=(r[c]===undefined||r[c]===null||r[c]==='')?'∅':String(r[c]); const i=e.map[k]; if(i!==undefined) arr[i]=1; out.push(...arr); }
  return out;
}

$("trainBtn").onclick = async ()=>{
  if(!trainRows.length) return; setStatus('training…');
  if(MODE==='tab'){
    fitEnc();
    const X=tf.tensor2d(trainRows.map(rowToX_tab));
    const y=tf.tensor2d(trainRows.map(r=>[Number(r[target])]))
    model=tf.sequential({layers:[
      tf.layers.dense({units:128,activation:'relu',inputShape:[X.shape[1]]}),
      tf.layers.dropout({rate:0.15}),
      tf.layers.dense({units:64,activation:'relu'}),
      tf.layers.dense({units:1})
    ]});
    model.compile({optimizer:tf.train.adam(0.001),loss:'meanSquaredError'});
    await model.fit(X,y,{epochs:20,batchSize:Math.min(256,Math.max(32,Math.floor(X.shape[0]/20)||64)),shuffle:true});
    setStatus('model ready');
    $("predictBtn").disabled = !testRows.length;
  } else {
    const {X,y} = buildSequenceTensors(trainRows, true);
    model = buildRnnModel(seqInfo.featDim);
    await model.fit(X,y,{epochs:15,batchSize:64,shuffle:true,validationSplit:0.2});
    setStatus('RNN model ready');
    $("predictBtn").disabled = !testRows.length;
  }
};

$("predictBtn").onclick = ()=>{
  if(!model||!testRows.length) return;
  if(MODE==='tab'){
    const X=tf.tensor2d(testRows.map(rowToX_tab));
    const yhat=model.predict(X);
    yhat.data().then(arr=>{
      preds=testRows.map((r,i)=>({...r,prediction:Number(arr[i].toFixed(4))}));
      const n=arr.length; const val = n===1? arr[0] : (arr.reduce((a,b)=>a+b,0)/n);
      setValue(Number(val).toFixed(2));
      $("downloadBtn").disabled = false;
    });
  } else {
    const {X} = buildSequenceTensors(testRows, false);
    const yhat=model.predict(X);
    yhat.data().then(arr=>{
      // aggregate per sequence
      const n=arr.length; const avg = arr.reduce((a,b)=>a+b,0)/Math.max(1,n);
      setValue(Number(avg).toFixed(2));
      preds = testRows; // optional: could emit per id predictions if mapping kept
      $("downloadBtn").disabled = false;
    });
  }
};

$("downloadBtn").onclick = ()=>{
  if(!preds||!preds.length) return;
  const header=Object.keys(preds[0]);
  const csv=[header.join(','), ...preds.map(r=> header.map(h=> JSON.stringify(r[h]??'')).join(','))].join('
');
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='predictions.csv'; a.click(); URL.revokeObjectURL(url);
};

$("resetBtn").onclick = ()=>{ location.reload(); };

// ===== Manual calculator (only for tabular) =====
const modal=$("modal"), formBox=$("formBox"), calcOut=$("calcOut");
$("manualBtn").onclick=()=>{ if(MODE!=='tab' || !columns.length){return;} buildForm(); modal.style.display='flex'; };
$("closeBtn").onclick=()=>{ modal.style.display='none'; };
$("calcBtn").onclick=()=>{ if(!model || MODE!=='tab') return; const r=readForm(); const x=tf.tensor2d([rowToX_tab(r)]); model.predict(x).data().then(a=>{ calcOut.textContent = a[0].toFixed(2); }); };

function buildForm(){
  formBox.innerHTML='';
  const list=(columns||[]).filter(c=>c!==target);
  for(let i=0;i<list.length;i+=2){
    const row=document.createElement('div'); row.className='row';
    [list[i], list[i+1]].filter(Boolean).forEach(c=>{
      const wrap=document.createElement('div');
      const lab=document.createElement('label'); lab.textContent=c; wrap.appendChild(lab);
      if(catCols.includes(c)){
        const sel=document.createElement('select'); sel.setAttribute('data-col',c);
        const uniq=[...new Set(trainRows.map(r=> (r[c]===undefined||r[c]===null||r[c]==='')?'∅':String(r[c])) )];
        uniq.forEach(v=>{ const o=document.createElement('option'); o.value=v; o.textContent=v; sel.appendChild(o); });
        wrap.appendChild(sel);
      } else {
        const inp=document.createElement('input'); inp.type='number'; inp.step='any'; inp.setAttribute('data-col',c);
        const nums=trainRows.map(r=> Number(r[c])).filter(v=>!Number.isNaN(v)).sort((a,b)=>a-b);
        inp.value = nums[Math.floor(nums.length/2)]||0; wrap.appendChild(inp);
      }
      row.appendChild(wrap);
    });
    formBox.appendChild(row);
  }
}

function readForm(){
  const r={};
  formBox.querySelectorAll('[data-col]').forEach(node=>{ const c=node.getAttribute('data-col'); r[c]= node.tagName==='SELECT'? node.value : Number(node.value); });
  return r;
}

// ======== SEQUENCE (RNN) helpers ========
function detectSeqSchema(){
  // id column
  const candId=['customer_id','id','user_id','policy_id'];
  seqInfo.idCol = candId.find(c=> columns.includes(c)) || columns[0];
  // time column
  const candT=['t','time','date','month'];
  seqInfo.timeCol = candT.find(c=> columns.includes(c)) || null;
  // features exclude target, id, time
  seqInfo.featCols = columns.filter(c=> c!==target && c!==seqInfo.idCol && c!==seqInfo.timeCol);
  // guess numeric/cat per feature (reuse tabular logic on featCols)
  const rows=trainRows;
  const isNum={};
  seqInfo.featCols.forEach(c=>{
    const vals=rows.map(r=>r[c]).filter(v=>v!==null&&v!==undefined);
    const numRatio = vals.filter(v=> typeof v==='number' && !Number.isNaN(v)).length/Math.max(vals.length,1);
    isNum[c]= numRatio>0.85 && new Set(vals).size>15;
  });
  // Build enc/normalizers for features
  enc={};
  numCols = seqInfo.featCols.filter(c=> isNum[c]);
  catCols = seqInfo.featCols.filter(c=> !isNum[c]);
  // reuse tabular encoders
  for(const c of numCols){
    const xs=trainRows.map(r=>Number(r[c])).filter(v=>!Number.isNaN(v));
    const mean=xs.reduce((a,b)=>a+b,0)/Math.max(xs.length,1);
    const std=Math.sqrt(xs.reduce((a,b)=>a+(b-mean)*(b-mean),0)/Math.max(xs.length,1))||1;
    const med=xs.slice().sort((a,b)=>a-b)[Math.floor(xs.length/2)]||0;
    enc[c]={type:'num',mean,std,med};
  }
  for(const c of catCols){
    const uniq=[...new Set(trainRows.map(r=> (r[c]===undefined||r[c]===null||r[c]==='')?'∅':String(r[c])) )];
    enc[c]={type:'cat',map:Object.fromEntries(uniq.map((k,i)=>[k,i])),size:uniq.length};
  }
  // compute featDim
  seqInfo.featDim = numCols.length + catCols.reduce((a,c)=>a+(enc[c]?.size||0),0);
}

function rowToX_seq(r){
  const out=[];
  for(const c of numCols){ const e=enc[c]; const v=Number(r[c]); const x=Number.isNaN(v)?e.med:v; out.push((x-e.mean)/e.std); }
  for(const c of catCols){ const e=enc[c]; const arr=new Array(e.size).fill(0); const k=(r[c]===undefined||r[c]===null||r[c]==='')?'∅':String(r[c]); const i=e.map[k]; if(i!==undefined) arr[i]=1; out.push(...arr); }
  return out;
}

function buildSequenceTensors(data, isTrain){
  if(!seqInfo.idCol){ detectSeqSchema(); }
  const byId=new Map();
  for(const r of data){
    const id=r[seqInfo.idCol]; if(!byId.has(id)) byId.set(id,[]); byId.get(id).push(r);
  }
  const T=seqInfo.T; const sequences=[]; const labels=[];
  byId.forEach((arr)=>{
    // sort by time if available
    if(seqInfo.timeCol){ arr.sort((a,b)=> (a[seqInfo.timeCol]>b[seqInfo.timeCol]?1:-1)); }
    const steps=arr.map(rowToX_seq);
    if(steps.length===0) return;
    // use last row's target as label (sequence-to-one)
    const y = Number(arr[arr.length-1][target]); if(!Number.isFinite(y)) return;
    // take last T steps, pad at front with zeros
    const pad = Math.max(0, T-steps.length);
    const zero = new Array(seqInfo.featDim).fill(0);
    const seq = [...Array(pad).fill(zero), ...steps.slice(-T)];
    sequences.push(seq);
    labels.push(y);
  });
  const X = tf.tensor3d(sequences); // [B,T,F]
  const y = tf.tensor2d(labels.map(v=>[v]));
  return {X,y};
}

function buildRnnModel(featDim){
  const input=tf.input({shape:[seqInfo.T, featDim]});
  const td=tf.layers.timeDistributed({layer: tf.layers.dense({units:32, activation:'relu'})}).apply(input);
  const gru=tf.layers.gru({units:64, returnSequences:false, dropout:0.1}).apply(td);
  const out=tf.layers.dense({units:1}).apply(gru);
  const m=tf.model({inputs:input, outputs:out});
  m.compile({optimizer:tf.train.adam(1e-3), loss:'meanSquaredError'});
  return m;
}
</script>
</body>
</html>
